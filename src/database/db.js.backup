const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? {
    // SECURITY FIX: Secure SSL configuration for Supabase
    rejectUnauthorized: false, // Required for Supabase hosted service
    // But we still verify the certificate authority
    ca: undefined // Let Node.js use its default CA bundle
  } : false
});

class Database {
  static async query(text, params) {
    const client = await pool.connect();
    try {
      const result = await client.query(text, params);
      return result;
    } catch (error) {
      console.error('Database query error:', error);
      throw error;
    } finally {
      client.release();
    }
  }

  static async getUser(discordId) {
    const query = 'SELECT * FROM users WHERE discord_id = $1';
    const result = await this.query(query, [discordId]);
    return result.rows[0] || null;
  }

  static async createUser(userData) {
    const query = `
      INSERT INTO users (discord_id, audius_user_id, audius_handle, audius_name, tokens_balance)
      VALUES ($1, $2, $3, $4, $5)
      ON CONFLICT (discord_id) 
      DO UPDATE SET 
        audius_user_id = $2,
        audius_handle = $3,
        audius_name = $4,
        last_updated = NOW()
      RETURNING *
    `;
    const result = await this.query(query, [
      userData.discordId,
      userData.audiusUserId,
      userData.audiusHandle,
      userData.audiusName,
      userData.tokensBalance || 0
    ]);
    return result.rows[0];
  }

  static async updateUserTokens(discordId, tokens) {
    const query = `
      UPDATE users 
      SET tokens_balance = tokens_balance + $2,
          total_rewards_claimed = total_rewards_claimed + 1,
          last_updated = NOW()
      WHERE discord_id = $1
      RETURNING *
    `;
    const result = await this.query(query, [discordId, tokens]);
    return result.rows[0];
  }

  static async deleteUser(discordId) {
    const query = 'DELETE FROM users WHERE discord_id = $1 RETURNING *';
    const result = await this.query(query, [discordId]);
    return result.rows[0];
  }

  static async isAdmin(discordId) {
    const query = 'SELECT * FROM admins WHERE discord_id = $1';
    const result = await this.query(query, [discordId]);
    return result.rows.length > 0;
  }

  static async addAdmin(discordId) {
    const query = `
      INSERT INTO admins (discord_id, added_by, added_at)
      VALUES ($1, 'SYSTEM', NOW())
      ON CONFLICT (discord_id) DO NOTHING
      RETURNING *
    `;
    const result = await this.query(query, [discordId]);
    return result.rows[0];
  }

  static async initializeAdmins() {
    try {
      const adminIds = process.env.ADMIN_DISCORD_ID;
      if (adminIds) {
        const ids = adminIds.split(',').map(id => id.trim()).filter(id => id);
        
        for (const discordId of ids) {
          await this.addAdmin(discordId);
          console.log(`✅ Admin initialized: ${discordId}`);
        }
        
        console.log(`🔐 Initialized ${ids.length} admin(s)`);
      }
    } catch (error) {
      console.error('Error initializing admins:', error);
    }
  }

  static async createRaid(raidData) {
    const query = `
      INSERT INTO raids (
        track_id, track_url, track_title, track_artist, track_artwork_url,
        streams_goal, reward_amount, channel_id, guild_id, creator_id,
        duration_minutes, expires_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
      RETURNING *
    `;
    const expiresAt = new Date(Date.now() + raidData.durationMinutes * 60 * 1000);
    const result = await this.query(query, [
      raidData.trackId,
      raidData.trackUrl,
      raidData.trackTitle,
      raidData.trackArtist,
      raidData.trackArtworkUrl,
      raidData.streamsGoal,
      raidData.rewardAmount,
      raidData.channelId,
      raidData.guildId,
      raidData.creatorId,
      raidData.durationMinutes,
      expiresAt
    ]);
    return result.rows[0];
  }

  static async getActiveRaids() {
    const query = `
      SELECT * FROM raids 
      WHERE status = 'active' AND expires_at > NOW()
    `;
    const result = await this.query(query);
    return result.rows;
  }

  static async getRaid(raidId) {
    const query = 'SELECT * FROM raids WHERE id = $1';
    const result = await this.query(query, [raidId]);
    return result.rows[0];
  }

  static async updateRaidProgress(raidId, currentStreams) {
    const query = `
      UPDATE raids 
      SET current_streams = $2 
      WHERE id = $1 
      RETURNING *
    `;
    const result = await this.query(query, [raidId, currentStreams]);
    return result.rows[0];
  }

  static async completeRaid(raidId) {
    const query = `
      UPDATE raids 
      SET status = 'completed', completed_at = NOW()
      WHERE id = $1 
      RETURNING *
    `;
    const result = await this.query(query, [raidId]);
    return result.rows[0];
  }

  static async addRaidParticipant(raidId, discordId, audiusUserId) {
    const query = `
      INSERT INTO raid_participants (raid_id, discord_id, audius_user_id, listen_start_time, last_check, is_listening, total_listen_duration)
      VALUES ($1, $2, $3, NOW(), NOW(), TRUE, 0)
      ON CONFLICT (raid_id, discord_id) DO NOTHING
      RETURNING *
    `;
    const result = await this.query(query, [raidId, discordId, audiusUserId]);
    return result.rows[0];
  }

  static async getParticipantsNeedingVerification() {
    const query = `
      SELECT rp.*, r.track_id, r.track_title, r.reward_amount, r.id as raid_id, u.audius_user_id
      FROM raid_participants rp 
      JOIN raids r ON rp.raid_id = r.id 
      JOIN users u ON rp.discord_id = u.discord_id
      WHERE rp.is_listening = TRUE 
      AND rp.total_listen_duration = 0
      AND rp.listen_start_time IS NOT NULL
      AND rp.listen_start_time <= NOW() - INTERVAL '20 seconds'
      AND (rp.last_check IS NULL OR rp.last_check = rp.listen_start_time)
      AND r.status = 'active' 
      AND r.expires_at > NOW()
    `;
    const result = await this.query(query);
    return result.rows;
  }

  static async updateParticipantListenTime(raidId, discordId, duration) {
    const query = `
      UPDATE raid_participants 
      SET total_listen_duration = $3,
          qualified = CASE WHEN $3 >= $4 THEN true ELSE false END
      WHERE raid_id = $1 AND discord_id = $2
      RETURNING *
    `;
    const result = await this.query(query, [raidId, discordId, duration, process.env.MINIMUM_LISTEN_TIME || 30]);
    return result.rows[0];
  }

  static async getQualifiedParticipants(raidId) {
    const query = `
      SELECT rp.*, u.audius_handle, u.audius_name
      FROM raid_participants rp
      LEFT JOIN users u ON rp.discord_id = u.discord_id
      WHERE rp.raid_id = $1 AND rp.qualified = true AND rp.claimed_reward = false
    `;
    const result = await this.query(query, [raidId]);
    return result.rows;
  }

  static async claimReward(raidId, discordId) {
    const query = `
      UPDATE raid_participants 
      SET claimed_reward = true, claimed_at = NOW()
      WHERE raid_id = $1 AND discord_id = $2 AND qualified = true
      RETURNING *
    `;
    const result = await this.query(query, [raidId, discordId]);
    return result.rows[0];
  }

  static async getLeaderboard(limit = 10) {
    const query = `
      SELECT discord_id, audius_handle, audius_name, tokens_balance, total_raids_participated
      FROM users 
      WHERE tokens_balance > 0
      ORDER BY tokens_balance DESC, total_raids_participated DESC
      LIMIT $1
    `;
    const result = await this.query(query, [limit]);
    return result.rows;
  }

  static async createOAuthSession(state, discordId) {
    const expiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes
    const query = `
      INSERT INTO oauth_sessions (state, discord_id, expires_at)
      VALUES ($1, $2, $3)
      RETURNING *
    `;
    const result = await this.query(query, [state, discordId, expiresAt]);
    return result.rows[0];
  }

  static async getOAuthSession(state) {
    const query = `
      SELECT * FROM oauth_sessions 
      WHERE state = $1 AND expires_at > NOW()
    `;
    const result = await this.query(query, [state]);
    return result.rows[0];
  }

  static async deleteOAuthSession(state) {
    const query = 'DELETE FROM oauth_sessions WHERE state = $1';
    await this.query(query, [state]);
  }

  static async cleanupExpiredSessions() {
    const query = 'DELETE FROM oauth_sessions WHERE expires_at < NOW()';
    await this.query(query);
  }
}

module.exports = Database; 